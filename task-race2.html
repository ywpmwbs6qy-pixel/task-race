<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#111111"/>
  <title>Task Race</title>
  <style>
    :root{
      --bg:#0f1115; --card:#171a21; --muted:#9aa3b2; --text:#e9eef7;
      --accent:#6ee7ff; --good:#4ade80; --bad:#fb7185; --line:#262b36;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial;
      background:linear-gradient(180deg,#0b0d12, #0f1115 30%, #0f1115);
      color:var(--text);
      padding: max(16px, env(safe-area-inset-top)) 16px max(20px, env(safe-area-inset-bottom));
    }
    h1{font-size:20px; margin: 4px 0 14px; letter-spacing:.2px}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .grid{display:grid; grid-template-columns: 1fr; gap:12px; max-width:900px; margin:0 auto}
    .card{
      background:rgba(23,26,33,.95);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .card h2{font-size:14px; margin:0 0 10px; color:#cfd6e6; font-weight:650; letter-spacing:.2px}
    .muted{color:var(--muted); font-size:12px}
    input, select{
      width:auto; background:#0f131b; border:1px solid var(--line);
      color:var(--text); border-radius:10px; padding:10px 10px; outline:none;
    }
    input[type="number"]{width:110px}
    input[type="text"]{flex:1; min-width:180px}
    button{
      border:1px solid var(--line);
      background:#101522;
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-weight:650;
      letter-spacing:.2px;
      cursor:pointer;
    }
    button.primary{
      background: linear-gradient(135deg, rgba(110,231,255,.22), rgba(110,231,255,.05));
      border-color: rgba(110,231,255,.45);
    }
    button.good{border-color: rgba(74,222,128,.55); background: rgba(74,222,128,.12)}
    button.bad{border-color: rgba(251,113,133,.55); background: rgba(251,113,133,.12)}
    button:disabled{opacity:.5; cursor:not-allowed}
    .pill{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:#0f131b;
      font-size:12px;
      color:#cfd6e6;
    }
    .list{display:flex; flex-direction:column; gap:8px}

    /* 25% thinner rows: was padding 10px -> now 7px */
    .item{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:7px 10px;
      border:1px solid var(--line); border-radius:12px;
      background:#0f131b;
    }

    .item .left{display:flex; flex-direction:column; gap:2px}
    .name{font-weight:750}
    .tiny{font-size:12px; color:var(--muted)}
    .controls{display:flex; gap:8px; align-items:center}
    .hr{height:1px; background:var(--line); margin:10px 0}

    .big{
      font-size:28px; font-weight:850; letter-spacing:.4px;
      display:flex; align-items:baseline; gap:8px; flex-wrap:wrap;
    }
    .big span{font-size:12px; color:var(--muted); font-weight:650}

    /* ‚Äúlonger bar‚Äù feel: thicker + full-width block */
    .bar{
      height:14px;
      border-radius:999px;
      background:#0f131b;
      border:1px solid var(--line);
      overflow:hidden;
      width:100%;
      margin-top:8px;
    }
    .bar > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(110,231,255,.9), rgba(74,222,128,.85));
      transition: width .2s linear;
    }

    .ahead{color:var(--good)}
    .behind{color:var(--bad)}

    .twoCol{display:grid; grid-template-columns:1fr; gap:10px}
    @media (min-width: 860px){ .twoCol{grid-template-columns: 1fr 1fr} }

    .raceTop{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    @media (min-width: 860px){
      .raceTop{
        grid-template-columns: 1fr 1.3fr 1fr 1fr;
        align-items:end;
      }
    }

    .label{font-size:12px; color:var(--muted); margin-bottom:4px}
  </style>
</head>
<body>
  <div class="grid">
    <h1>Task Race</h1>

    <div class="twoCol">
      <div class="card">
        <h2>Task Library (saved on this phone)</h2>

        <div class="row">
          <input id="newTaskName" type="text" placeholder="Task name (e.g., 'Unload dishwasher')" />
          <input id="newTaskMins" type="number" min="0" step="0.5" placeholder="Minutes" />
          <button id="addToLibraryBtn" class="primary">Add to Library</button>
        </div>
        <div class="muted" style="margin-top:8px">
          Tip: durations can be decimals (e.g., 2.5 minutes).
        </div>

        <div class="hr"></div>

        <div class="row" style="justify-content:space-between">
          <div class="pill" id="libraryCountPill">0 tasks</div>
          <div class="row">
            <button id="clearLibraryBtn" class="bad">Clear Library</button>
          </div>
        </div>

        <div class="list" id="libraryList" style="margin-top:10px"></div>
      </div>

      <div class="card">
        <h2>Today‚Äôs Run List</h2>
        <div class="muted">Pick tasks from your library, reorder them, then race.</div>

        <div class="hr"></div>

        <div class="row" style="justify-content:space-between">
          <div class="pill" id="runStatsPill">0 tasks ‚Ä¢ 0:00 total</div>
          <div class="row">
            <button id="clearRunBtn" class="bad">Clear Run</button>
          </div>
        </div>

        <div class="list" id="runList" style="margin-top:10px"></div>
      </div>
    </div>

    <div class="card">
      <h2>Race Mode</h2>

      <!-- Estimated | Master | Time Ahead | Actual -->
      <div class="raceTop">
        <div>
          <div class="label">Estimated time</div>
          <div class="big" id="estimatedTime">0:00</div>
          <div class="muted" id="targetEndLine">Target end: ‚Äî</div>
<div class="muted" id="projectedEndLine">Projected end: ‚Äî</div>

        </div>

        <div>
          <div class="label">Master countdown</div>
          <div class="big" id="masterTime">0:00 <span id="masterMeta"></span></div>
          <div class="bar"><div id="masterBar"></div></div>
        </div>

        <div>
          <div class="label">Time ahead</div>
          <div class="big"><span class="ahead" id="timeAhead">0:00</span></div>
        </div>

        <div>
          <div class="label">Actual time</div>
          <div class="big" id="actualTime">0:00</div>
          <div class="muted" id="actualEndLine">Actual end: ‚Äî</div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row" style="justify-content:space-between; align-items:flex-start">
        <div style="min-width:260px; flex:1">
          <div class="muted">Current task</div>
          <div class="big" id="taskName">‚Äî</div>
          <div class="row" style="gap:12px">
            <div class="pill" id="taskIndexPill">0 / 0</div>
            <div class="pill" id="taskTargetPill">Target: 0:00</div>
          </div>
        </div>

        <div style="min-width:260px">
          <div class="muted">Task countdown</div>
          <div class="big" id="taskTime">0:00</div>
          <div class="row" style="gap:8px; margin-top:8px">
            <button id="startBtn" class="primary">Start</button>
            <button id="pauseBtn">Pause</button>
            <button id="doneBtn" class="good">Done</button>
            <button id="skipBtn" class="bad">Skip</button>
            <button id="resetRaceBtn">Reset</button>
          </div>
          <div class="muted" style="margin-top:8px">
            ‚ÄúDone‚Äù early banks the time you saved into ‚ÄúTime ahead.‚Äù
          </div>
        </div>
      </div>
    </div>

    <div class="muted" style="text-align:center">
      Data is stored locally on your phone. No account, no cloud.
    </div>
  </div>

<script>
(() => {
  const LS_LIBRARY = "taskrace_library_v1";
  const LS_RUN = "taskrace_run_v1";

  /** @type {{id:string,name:string,mins:number}[]} */
  let library = [];
  /** @type {{id:string,name:string,mins:number}[]} */
  let run = [];

  // Race state
  let race = {
    running:false,
    paused:false,
    interval:null,
    currentIndex:0,
    taskRemainingSec:0,
    masterRemainingSec:0,
    masterTotalSec:0,
    savedSec:0,              // ‚Äútime ahead‚Äù
    actualElapsedSec:0,      // actual time spent (excluding pauses)
    startedAt:null,
    targetEndAt:null,
    actualEndAt:null,
    _lastTick:null
  };

  const el = (id) => document.getElementById(id);

  function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }
  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function fmt(sec){
    sec = Math.max(0, Math.round(sec));
    const m = Math.floor(sec/60);
    const s = sec%60;
    return `${m}:${String(s).padStart(2,"0")}`;
  }

  function fmtClock(ms){
    if(!ms) return "‚Äî";
    const d = new Date(ms);
    return d.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" });
  }

  function load(){
    try{ library = JSON.parse(localStorage.getItem(LS_LIBRARY) || "[]"); } catch { library=[]; }
    try{ run = JSON.parse(localStorage.getItem(LS_RUN) || "[]"); } catch { run=[]; }
  }

  function save(){
    localStorage.setItem(LS_LIBRARY, JSON.stringify(library));
    localStorage.setItem(LS_RUN, JSON.stringify(run));
  }

  function totalRunSec(){
    return run.reduce((sum,t)=> sum + Math.round((t.mins||0)*60), 0);
  }

  function renderLibrary(){
    el("libraryCountPill").textContent = `${library.length} task${library.length===1?"":"s"}`;
    const wrap = el("libraryList");
    wrap.innerHTML = "";
    if(library.length === 0){
      wrap.innerHTML = `<div class="muted">No tasks yet. Add one above.</div>`;
      return;
    }
    library
      .slice()
      .sort((a,b)=> a.name.localeCompare(b.name))
      .forEach(t => {
        const div = document.createElement("div");
        div.className = "item";
        div.innerHTML = `
          <div class="left">
            <div class="name">${escapeHtml(t.name)}</div>
            <div class="tiny">${t.mins} min</div>
          </div>
          <div class="controls">
            <button data-add="${t.id}" class="primary">Add</button>
            <button data-del="${t.id}" class="bad">Delete</button>
          </div>
        `;
        wrap.appendChild(div);
      });

    wrap.querySelectorAll("button[data-add]").forEach(b => {
      b.addEventListener("click", () => {
        const id = b.getAttribute("data-add");
        const t = library.find(x => x.id===id);
        if(!t) return;
        run.push({ ...t, id: uid() }); // allow duplicates in run list
        save();
        renderRun();
        if(!race.running) updateRacePreview();
      });
    });

    wrap.querySelectorAll("button[data-del]").forEach(b => {
      b.addEventListener("click", () => {
        const id = b.getAttribute("data-del");
        library = library.filter(x => x.id !== id);
        save();
        renderLibrary();
      });
    });
  }

  function renderRun(){
    const total = totalRunSec();
    el("runStatsPill").textContent = `${run.length} task${run.length===1?"":"s"} ‚Ä¢ ${fmt(total)} total`;
    const wrap = el("runList");
    wrap.innerHTML = "";
    if(run.length === 0){
      wrap.innerHTML = `<div class="muted">Add tasks from the library to build your run.</div>`;
      return;
    }

    run.forEach((t, idx) => {
      const div = document.createElement("div");
      div.className = "item";
      div.innerHTML = `
        <div class="left">
          <div class="name">${idx+1}. ${escapeHtml(t.name)}</div>
          <div class="tiny">${t.mins} min</div>
        </div>
        <div class="controls">
          <button data-up="${idx}">‚Üë</button>
          <button data-down="${idx}">‚Üì</button>
          <button data-remove="${idx}" class="bad">Remove</button>
        </div>
      `;
      wrap.appendChild(div);
    });

    wrap.querySelectorAll("button[data-up]").forEach(b => {
      b.addEventListener("click", () => {
        const i = Number(b.getAttribute("data-up"));
        if(i<=0) return;
        [run[i-1], run[i]] = [run[i], run[i-1]];
        save(); renderRun();
        if(!race.running) updateRacePreview();
      });
    });
    wrap.querySelectorAll("button[data-down]").forEach(b => {
      b.addEventListener("click", () => {
        const i = Number(b.getAttribute("data-down"));
        if(i>=run.length-1) return;
        [run[i], run[i+1]] = [run[i+1], run[i]];
        save(); renderRun();
        if(!race.running) updateRacePreview();
      });
    });
    wrap.querySelectorAll("button[data-remove]").forEach(b => {
      b.addEventListener("click", () => {
        const i = Number(b.getAttribute("data-remove"));
        run.splice(i,1);
        save(); renderRun();
        if(!race.running) updateRacePreview();
      });
    });
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function setButtons(){
    const hasRun = run.length > 0;
    el("startBtn").disabled = !hasRun || race.running;
    el("pauseBtn").disabled = !race.running;
    el("doneBtn").disabled = !race.running;
    el("skipBtn").disabled = !race.running;
    el("resetRaceBtn").disabled = !hasRun;
  }

  function currentTask(){
    return run[race.currentIndex] || null;
  }

  function updateRacePreview(){
    const total = totalRunSec();

    el("estimatedTime").textContent = fmt(total);
    el("masterTime").childNodes[0].textContent = fmt(total) + " ";
    el("masterMeta").textContent = run.length ? `(${run.length} tasks)` : "";

    el("timeAhead").textContent = fmt(0);
    el("actualTime").textContent = fmt(0);

    el("targetEndLine").textContent = "Target end: ‚Äî";
    el("actualEndLine").textContent = "Actual end: ‚Äî";

    el("taskName").textContent = run.length ? run[0].name : "‚Äî";
    el("taskIndexPill").textContent = run.length ? `1 / ${run.length}` : "0 / 0";
    el("taskTargetPill").textContent = run.length ? `Target: ${fmt(run[0].mins*60)}` : "Target: 0:00";
    el("taskTime").textContent = run.length ? fmt(run[0].mins*60) : "0:00";

    el("masterBar").style.width = "0%";
    setButtons();
  }

  function startRace(){
    if(run.length === 0) return;

    race.running = true;
    race.paused = false;
    race.currentIndex = clamp(race.currentIndex, 0, run.length-1);
    race.savedSec = 0;
    race.actualElapsedSec = 0;

    race.masterTotalSec = totalRunSec();
    race.masterRemainingSec = race.masterTotalSec;

    const t = currentTask();
    race.taskRemainingSec = Math.round(t.mins*60);

    race.startedAt = Date.now();
    race.targetEndAt = race.startedAt + (race.masterTotalSec * 1000);
    race.actualEndAt = null;
    race._lastTick = null;

    el("targetEndLine").textContent = `Target end: ${fmtClock(race.targetEndAt)}`;
    el("actualEndLine").textContent = "Actual end: ‚Äî";

    tick(true);
    race.interval = setInterval(() => tick(false), 250);
    setButtons();
  }

  function pauseRace(){
    if(!race.running) return;
    race.paused = !race.paused;
    el("pauseBtn").textContent = race.paused ? "Resume" : "Pause";
    // reset tick reference so we don't ‚Äújump‚Äù when resuming
    if(!race.paused) race._lastTick = null;
  }

  function resetRace(){
    if(race.interval) clearInterval(race.interval);
    race = {
      running:false,
      paused:false,
      interval:null,
      currentIndex:0,
      taskRemainingSec:0,
      masterRemainingSec:0,
      masterTotalSec:0,
      savedSec:0,
      actualElapsedSec:0,
      startedAt:null,
      targetEndAt:null,
      actualEndAt:null,
      _lastTick:null
    };
    el("pauseBtn").textContent = "Pause";
    updateRacePreview();
  }

  function nextTask(){
    race.currentIndex++;
    if(race.currentIndex >= run.length){
      finishRace();
      return;
    }
    const t = currentTask();
    race.taskRemainingSec = Math.round(t.mins*60);
  }

  function doneTask(){
    if(!race.running) return;
    const saved = Math.max(0, Math.round(race.taskRemainingSec));
    race.savedSec += saved; // time ahead
    nextTask();
    tick(true);
  }

  function skipTask(){
    if(!race.running) return;
    nextTask();
    tick(true);
  }

  function finishRace(){
    if(race.interval) clearInterval(race.interval);
    race.running = false;
    race.paused = false;
    race.actualEndAt = Date.now();

    el("pauseBtn").textContent = "Pause";
    el("actualEndLine").textContent = `Actual end: ${fmtClock(race.actualEndAt)}`;

    setButtons();
    el("taskName").textContent = "Done üéâ";
    el("taskTime").textContent = "0:00";
    el("taskIndexPill").textContent = `${run.length} / ${run.length}`;
    el("taskTargetPill").textContent = "Target: 0:00";
  }

  function tick(force){
    if(!race.running && !force) return;

    // Update the ‚ÄúTarget end‚Äù line live: use current effective remaining to show projected end.
    // You asked for a clock that tells you when you should end, and updates when you actually ended.
    // This shows: Target end (fixed) + dynamic projected end implied by master countdown.
    if(race.running){
      el("targetEndLine").textContent = `Target end: ${fmtClock(race.targetEndAt)}`;
el("targetEndLine").textContent = `Target end: ${fmtClock(race.targetEndAt)}`;

    }

    if(race.running && !race.paused){
      const now = Date.now();
      if(!race._lastTick) race._lastTick = now;
      const deltaSec = (now - race._lastTick) / 1000;
      race._lastTick = now;

      race.masterRemainingSec -= deltaSec;
      race.taskRemainingSec -= deltaSec;

      // actual time only counts while running (excluding pauses)
      race.actualElapsedSec += deltaSec;
    }

    // Auto-advance task if it hits zero
    if(race.running && !race.paused && race.taskRemainingSec <= 0){
      race.taskRemainingSec = 0;
      nextTask();
    }

    // UI updates
    const total = Math.max(1, Math.round(race.masterTotalSec || totalRunSec() || 1));
    const estimated = race.masterTotalSec || totalRunSec();
    el("estimatedTime").textContent = fmt(estimated);

    // Effective remaining accounts for time-ahead ‚Äúbank‚Äù
    const effectiveRemaining = Math.max(0, Math.round((race.masterRemainingSec || 0) - (race.savedSec || 0)));
const projectedEndAt = Date.now() + (effectiveRemaining * 1000);
el("projectedEndLine").textContent = `Projected end: ${fmtClock(projectedEndAt)}`;
    const masterShown = race.running ? effectiveRemaining : estimated;

    // Master display
    el("masterTime").childNodes[0].textContent = fmt(masterShown) + " ";
    el("masterMeta").textContent = run.length ? `(${run.length} tasks)` : "";

    // Time ahead display
    el("timeAhead").textContent = fmt(race.savedSec || 0);

    // Actual time display
    el("actualTime").textContent = fmt(race.actualElapsedSec || 0);

    // Progress bar = time taken / total
    // time taken should be shown on the bar: fill is elapsed portion
    const elapsed = clamp((race.actualElapsedSec || 0), 0, total);
    const done = clamp(elapsed / total, 0, 1);
    el("masterBar").style.width = `${(done*100).toFixed(1)}%`;

    // Current task UI
    const t = currentTask();
    if(t){
      el("taskName").textContent = t.name;
      el("taskIndexPill").textContent = `${race.currentIndex+1} / ${run.length}`;
      el("taskTargetPill").textContent = `Target: ${fmt(t.mins*60)}`;
      el("taskTime").textContent = fmt(race.taskRemainingSec);
    } else if(!race.running){
      // preview state handled elsewhere
    }

    // If tasks completed
    if(race.running && race.currentIndex >= run.length){
      finishRace();
    }
  }

  // Wire up controls
  el("addToLibraryBtn").addEventListener("click", () => {
    const name = el("newTaskName").value.trim();
    const mins = Number(el("newTaskMins").value);
    if(!name) return alert("Task name?");
    if(!isFinite(mins) || mins <= 0) return alert("Minutes must be > 0.");
    library.push({ id: uid(), name, mins });
    el("newTaskName").value = "";
    el("newTaskMins").value = "";
    save();
    renderLibrary();
  });

  el("clearLibraryBtn").addEventListener("click", () => {
    if(!confirm("Clear your entire task library?")) return;
    library = [];
    save();
    renderLibrary();
  });

  el("clearRunBtn").addEventListener("click", () => {
    run = [];
    save();
    renderRun();
    resetRace();
  });

  el("startBtn").addEventListener("click", () => startRace());
  el("pauseBtn").addEventListener("click", () => pauseRace());
  el("doneBtn").addEventListener("click", () => doneTask());
  el("skipBtn").addEventListener("click", () => skipTask());
  el("resetRaceBtn").addEventListener("click", () => resetRace());

  // Init
  load();
  renderLibrary();
  renderRun();
  updateRacePreview();

})();
</script>
</body>
</html>
